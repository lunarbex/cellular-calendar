<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>n o w</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IM+Fell+English:ital@0;1&family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Inconsolata:wght@300;400&display=swap');

  :root {
    --bg: #0a0c0a;
    --membrane-active: #4a7c5a;
    --membrane-dormant: #2a3d2f;
    --membrane-spore: #1a2018;
    --membrane-resurgent: #8fbc6a;
    --charge: #a8d878;
    --text: #c8d8c0;
    --text-dim: #5a7060;
    --panel: rgba(12, 18, 14, 0.96);
    --threshold: #d4f0a0;
    --fodder-inner: rgba(168, 216, 120, 0.15);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    font-family: 'Inconsolata', monospace;
    color: var(--text);
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    cursor: crosshair;
  }

  #field { position: absolute; inset: 0; z-index: 1; }
  #mt-canvas { position: absolute; inset: 0; z-index: 5; pointer-events: none; }

  /* Wabi-sabi organic cells */
  .cell {
    position: absolute;
    cursor: pointer;
    z-index: 10;
    user-select: none;
    filter: url(#organic);
  }

  .cell-membrane {
    position: absolute;
    inset: 0;
    border-radius: 50%;
  }

  .cell-content {
    position: absolute;
    inset: 12%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    overflow: hidden;
  }

  .cell-intention {
    font-family: 'Crimson Text', serif;
    font-size: 13px;
    line-height: 1.3;
    text-align: center;
    font-style: italic;
    margin-bottom: 4px;
    max-width: 90%;
    word-wrap: break-word;
  }

  .cell-timespan {
    font-family: 'Inconsolata', monospace;
    font-size: 9px;
    color: var(--text-dim);
    letter-spacing: 0.5px;
    margin-bottom: 6px;
  }

  .fodder-in-cell {
    font-family: 'Crimson Text', serif;
    font-size: 10px;
    line-height: 1.4;
    color: var(--text-dim);
    text-align: center;
    max-width: 85%;
    max-height: 40%;
    overflow: hidden;
    position: relative;
  }

  .fodder-item-inner {
    background: var(--fodder-inner);
    padding: 3px 6px;
    margin: 2px;
    border-radius: 3px;
    display: inline-block;
    font-size: 9px;
    opacity: 0.7;
  }

  .state-dot {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    pointer-events: none;
    filter: blur(0.5px);
  }
  .state-dot.active { background: var(--membrane-active); box-shadow: 0 0 4px var(--membrane-active); }
  .state-dot.dormant { background: var(--membrane-dormant); }
  .state-dot.spore { background: var(--membrane-spore); opacity: 0.3; }
  .state-dot.resurgent { 
    background: var(--membrane-resurgent); 
    box-shadow: 0 0 6px var(--membrane-resurgent);
    animation: blink 1.2s ease-in-out infinite; 
  }

  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }

  /* State-based appearances */
  .cell[data-state="active"] .cell-membrane {
    background: radial-gradient(ellipse at 35% 40%, rgba(74,124,90,0.12), rgba(74,124,90,0.04));
  }
  .cell[data-state="dormant"] .cell-membrane {
    background: radial-gradient(ellipse at 35% 40%, rgba(42,61,47,0.06), rgba(42,61,47,0.02));
    opacity: 0.6;
  }
  .cell[data-state="spore"] .cell-membrane {
    background: radial-gradient(ellipse at 35% 40%, rgba(26,32,24,0.04), rgba(26,32,24,0.01));
    opacity: 0.3;
    filter: blur(1.2px);
  }
  .cell[data-state="resurgent"] .cell-membrane {
    background: radial-gradient(ellipse at 35% 40%, rgba(143,188,106,0.18), rgba(143,188,106,0.08));
    animation: resurgePulse 3s ease-in-out infinite;
  }

  @keyframes resurgePulse {
    0%,100% { filter: brightness(1) blur(0px); }
    50% { filter: brightness(1.2) blur(0.3px); }
  }

  .cell.threshold .cell-membrane {
    background: radial-gradient(ellipse at 35% 40%, rgba(212,240,160,0.25), rgba(212,240,160,0.1)) !important;
    animation: thresholdPulse 2s ease-in-out infinite !important;
  }

  @keyframes thresholdPulse {
    0%,100% { transform: scale(1); filter: brightness(1.1); }
    50% { transform: scale(1.04); filter: brightness(1.3); }
  }

  .cell.selected .cell-membrane {
    outline: 1px solid rgba(200,216,192,0.35);
    outline-offset: 10px;
  }

  /* Charge arc - hand-drawn quality */
  .charge-svg {
    position: absolute;
    inset: -8px;
    width: calc(100% + 16px);
    height: calc(100% + 16px);
    pointer-events: none;
    filter: url(#roughen);
  }

  /* Panel */
  #panel {
    position: fixed;
    right: 0; top: 0;
    width: 300px;
    height: 100vh;
    background: var(--panel);
    border-left: 1px solid rgba(74,124,90,0.12);
    padding: 32px 20px 20px;
    z-index: 100;
    display: none;
    overflow-y: auto;
    font-size: 12px;
  }
  #panel.open { display: block; }

  #panel h2 {
    font-family: 'Crimson Text', serif;
    font-size: 16px;
    font-weight: 600;
    color: var(--text);
    margin-bottom: 18px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(74,124,90,0.15);
  }

  .field-label {
    display: block;
    color: var(--text-dim);
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    margin-top: 14px;
    margin-bottom: 5px;
  }

  input[type="text"], input[type="number"], textarea, select {
    width: 100%;
    background: rgba(74,124,90,0.05);
    border: 1px solid rgba(74,124,90,0.18);
    color: var(--text);
    padding: 7px 9px;
    font-family: 'Inconsolata', monospace;
    font-size: 12px;
    border-radius: 2px;
    outline: none;
  }
  input:focus, textarea:focus, select:focus {
    border-color: rgba(74,124,90,0.45);
  }

  .timespan-row { display: flex; gap: 6px; }
  .timespan-row input { flex: 1; }
  .timespan-row select { flex: 0 0 86px; }

  .state-selector { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 4px; }

  .state-btn {
    padding: 6px;
    border: 1px solid rgba(74,124,90,0.18);
    background: transparent;
    color: var(--text-dim);
    font-family: 'Inconsolata', monospace;
    font-size: 10px;
    cursor: pointer;
    border-radius: 2px;
    transition: all 0.2s;
  }
  .state-btn:hover { border-color: rgba(74,124,90,0.45); color: var(--text); }
  .state-btn.sel { background: rgba(74,124,90,0.12); border-color: var(--membrane-active); color: var(--text); }

  .charge-bar-outer { width:100%; height:2px; background:rgba(74,124,90,0.1); border-radius:2px; margin-top:5px; overflow:hidden; }
  .charge-bar-inner { height:100%; background: var(--charge); border-radius:2px; transition: width 0.5s ease; }

  .fodder-item {
    padding: 6px 9px;
    margin: 4px 0;
    border-left: 1px solid rgba(74,124,90,0.25);
    font-size: 11px;
    font-family: 'Crimson Text', serif;
    color: var(--text-dim);
    cursor: pointer;
    font-style: italic;
    transition: all 0.15s;
    line-height: 1.5;
  }
  .fodder-item:hover { color: var(--text); border-left-color: var(--membrane-active); background: rgba(74,124,90,0.05); }

  .fodder-add { display: flex; gap: 5px; margin-top: 6px; }
  .fodder-add input { flex: 1; }

  .btn {
    background: transparent;
    border: 1px solid rgba(74,124,90,0.25);
    color: var(--text-dim);
    padding: 6px 11px;
    font-family: 'Inconsolata', monospace;
    font-size: 11px;
    cursor: pointer;
    border-radius: 2px;
    transition: all 0.2s;
  }
  .btn:hover { border-color: var(--membrane-active); color: var(--text); }
  .btn.danger { border-color: rgba(120,60,60,0.35); color: rgba(180,100,100,0.6); }
  .btn.danger:hover { border-color: rgba(180,80,80,0.55); color: rgba(220,120,120,0.85); }
  .btn.active-mode { background: rgba(74,124,90,0.14); border-color: var(--membrane-active); color: var(--text); }

  hr.div { border:none; border-top: 1px solid rgba(74,124,90,0.09); margin: 14px 0; }

  #close-panel {
    position: absolute; top: 10px; right: 12px;
    background: transparent; border: none;
    color: var(--text-dim); font-size: 18px;
    cursor: pointer; line-height: 1;
  }
  #close-panel:hover { color: var(--text); }

  #topbar {
    position: fixed; top: 0; left: 0; right: 300px;
    height: 46px; z-index: 50;
    display: flex; align-items: center;
    padding: 0 18px; gap: 8px;
    background: linear-gradient(to bottom, rgba(9,12,10,0.92), transparent);
  }

  #title {
    font-family: 'Crimson Text', serif;
    font-size: 14px; font-weight: 600; font-style: italic;
    color: var(--text-dim); letter-spacing: 6px;
    margin-right: 10px;
  }

  #status {
    position: fixed; bottom: 14px; left: 18px;
    font-size: 10px; color: var(--text-dim);
    z-index: 50; pointer-events: none;
    letter-spacing: 0.3px;
    transition: opacity 0.5s;
    font-family: 'Crimson Text', serif;
    font-style: italic;
  }

  #threshold-flash {
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center, rgba(212,240,160,0.08) 0%, transparent 65%);
    pointer-events: none; z-index: 200;
    opacity: 0; transition: opacity 0.4s ease;
  }
  #threshold-flash.flash { opacity: 1; transition: opacity 0s; }

  .ribosome-hint {
    position: fixed; bottom: 36px;
    left: 50%; transform: translateX(-50%);
    background: var(--panel);
    border: 1px solid rgba(143,188,106,0.25);
    padding: 10px 16px;
    font-family: 'Crimson Text', serif;
    font-style: italic; font-size: 12px;
    color: var(--membrane-resurgent);
    z-index: 150; max-width: 480px;
    text-align: center;
    opacity: 0; transition: opacity 0.6s ease;
    pointer-events: none; border-radius: 2px;
    line-height: 1.6;
  }
  .ribosome-hint.visible { opacity: 1; }

  #panel-empty {
    color: var(--text-dim);
    font-style: italic;
    font-family: 'Crimson Text', serif;
    font-size: 13px; text-align: center;
    margin-top: 50px; line-height: 2;
  }

  input[type="color"] {
    width:100%; height:30px;
    border: 1px solid rgba(74,124,90,0.18);
    background: rgba(74,124,90,0.05);
    cursor: pointer; border-radius: 2px; padding: 2px;
  }
  input[type="range"] { width:100%; accent-color: var(--membrane-active); margin-top:2px; }

  ::-webkit-scrollbar { width: 3px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: rgba(74,124,90,0.25); border-radius:2px; }

  /* SVG filters for organic quality */
  svg.filters { position: absolute; width: 0; height: 0; }
</style>
</head>
<body>

<!-- SVG filters for wabi-sabi aesthetic -->
<svg class="filters">
  <defs>
    <filter id="organic">
      <feTurbulence type="fractalNoise" baseFrequency="0.4" numOctaves="2" seed="2"/>
      <feDisplacementMap in="SourceGraphic" scale="1.5"/>
    </filter>
    <filter id="roughen">
      <feTurbulence type="fractalNoise" baseFrequency="1.2" numOctaves="1" result="noise"/>
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="0.8" xChannelSelector="R" yChannelSelector="G"/>
    </filter>
  </defs>
</svg>

<canvas id="field"></canvas>
<canvas id="mt-canvas"></canvas>
<div id="threshold-flash"></div>

<div id="topbar">
  <span id="title">n &nbsp; o &nbsp; w</span>
  <button class="btn" id="btn-new">+ cell</button>
  <button class="btn" id="btn-connect">connect</button>
  <button class="btn" id="btn-sound">♪ on</button>
</div>

<div id="status">inhabit like you live here</div>

<div id="panel">
  <button id="close-panel">×</button>
  <h2 id="panel-title">cell</h2>
  <div id="panel-content">
    <div id="panel-empty">select a cell<br>to tend it</div>
  </div>
</div>

<div class="ribosome-hint" id="ribosome"></div>

<script>
// ── Audio ──────────────────────────────────────────────────────────────────
let audioCtx = null;
let soundOn = true;

function audio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function tone(freq, type, dur, vol=0.07, attack=0.02) {
  if (!soundOn) return;
  try {
    const ctx = audio();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.connect(g); g.connect(ctx.destination);
    o.type = type; o.frequency.value = freq;
    g.gain.setValueAtTime(0, ctx.currentTime);
    g.gain.linearRampToValueAtTime(vol, ctx.currentTime + attack);
    g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
    o.start(); o.stop(ctx.currentTime + dur + 0.1);
  } catch(e) {}
}

const sounds = {
  newCell:    () => tone(523, 'sine', 0.35, 0.05),
  connect:    () => { tone(220,'sine',1.2,0.05); setTimeout(()=>tone(330,'sine',0.9,0.04),200); },
  threshold:  () => { [174,261,349,523].forEach((f,i)=>setTimeout(()=>tone(f,'sine',1.2,0.05),i*200)); },
  dissolve:   () => { tone(440,'sine',2,0.04,0.15); setTimeout(()=>tone(220,'sine',2.5,0.03,0.25),350); },
  resurge:    () => { [130,196,261,392].forEach((f,i)=>setTimeout(()=>tone(f,'sine',2,0.05),i*450)); },
};

// ── Canvas ─────────────────────────────────────────────────────────────────
const fCanvas = document.getElementById('field');
const fCtx = fCanvas.getContext('2d');
const mCanvas = document.getElementById('mt-canvas');
const mCtx = mCanvas.getContext('2d');

function resize() {
  fCanvas.width = mCanvas.width = window.innerWidth;
  fCanvas.height = mCanvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ── State ──────────────────────────────────────────────────────────────────
let cells = [];
let tubes = [];
let compost = [];
let selected = null;
let connectMode = false;
let connectFrom = null;
let dragging = null;
let dragOX = 0, dragOY = 0;
let nextId = 1;
let ribTimer = null;

const CHARGE_THRESHOLD = 78;
const CHARGE_DECAY_RATE = 0.015;
const CHARGE_PER_VISIT = 9;
const DORMANT_IDLE_S = 90;

const RIBOSOME = {
  threshold: 'threshold dynamics — perturbations cascade into new order (bifurcation)',
  connection: 'coupled oscillators — rhythms entrain and transform each other',
  resurge:    'emergence from dormancy — pattern persists through phase transition',
  dissolve:   'dissolution into matrix — structure releases, medium enriches',
  charge:     'resonance fields — potential accumulates, seeks discharge',
  compost:    'nutrient cycling — what dissolves becomes available to the living',
  default:    'you are inhabiting a living system',
};

// ── Cell ───────────────────────────────────────────────────────────────────
class Cell {
  constructor(x, y) {
    this.id = nextId++;
    this.x = x; this.y = y;
    this.intention = '';
    this.timespan = 7; this.unit = 'days';
    this.color = '#4a7c5a';
    this.size = 120;
    this.fodder = [];
    this.state = 'active';
    this.charge = 12;
    this.lastVisit = Date.now();
    this.born = Date.now();
    this.isThreshold = false;
    this.el = this.build();
  }

  build() {
    const el = document.createElement('div');
    el.className = 'cell';
    el.dataset.state = 'active';
    el.dataset.id = this.id;
    this.position(el);

    // Create organic membrane with hand-drawn quality
    const irregularity = this.generateIrregularPath();
    
    el.innerHTML = `
      <svg class="cell-membrane" viewBox="0 0 100 100">
        <defs>
          <radialGradient id="grad-${this.id}" cx="35%" cy="40%">
            <stop offset="0%" stop-color="${this.color}" stop-opacity="0.15"/>
            <stop offset="100%" stop-color="${this.color}" stop-opacity="0.05"/>
          </radialGradient>
        </defs>
        <path class="membrane-path" d="${irregularity}" 
          fill="url(#grad-${this.id})" 
          stroke="${this.color}" 
          stroke-width="0.8" 
          opacity="0.7"
          filter="url(#roughen)"/>
      </svg>
      <svg class="charge-svg" viewBox="0 0 116 116">
        <circle class="carc" cx="58" cy="58" r="54"
          fill="none" stroke="${this.color}" stroke-width="0.6"
          stroke-dasharray="0 340" stroke-linecap="round"
          transform="rotate(-90 58 58)"
          opacity="0.4"
          filter="url(#roughen)"/>
      </svg>
      <div class="state-dot active"></div>
      <div class="cell-content">
        <div class="cell-intention">forming...</div>
        <div class="cell-timespan">7 days</div>
        <div class="fodder-in-cell"></div>
      </div>
    `;

    document.body.appendChild(el);

    el.addEventListener('mousedown', e => {
      if (connectMode) { this.handleConnect(); return; }
      e.stopPropagation();
      dragging = this;
      dragOX = e.clientX - this.x;
      dragOY = e.clientY - this.y;
    });

    el.addEventListener('click', e => {
      if (!connectMode) { e.stopPropagation(); this.visit(); selectCell(this); }
    });

    return el;
  }

  generateIrregularPath() {
    // Generate organic, imperfect circle path
    const points = 60;
    const baseRadius = 45;
    let path = 'M ';
    
    for (let i = 0; i <= points; i++) {
      const angle = (i / points) * Math.PI * 2;
      const variation = (Math.sin(angle * 3) * 0.7 + Math.sin(angle * 5) * 0.4 + Math.sin(angle * 7) * 0.3);
      const r = baseRadius + variation;
      const x = 50 + Math.cos(angle) * r;
      const y = 50 + Math.sin(angle) * r;
      path += i === 0 ? `${x},${y} ` : `L ${x},${y} `;
    }
    path += 'Z';
    return path;
  }

  position(el) {
    const s = el || this.el;
    s.style.left = (this.x - this.size/2) + 'px';
    s.style.top  = (this.y - this.size/2) + 'px';
    s.style.width = s.style.height = this.size + 'px';
  }

  move(x, y) {
    this.x = x; this.y = y;
    this.position();
  }

  visit() {
    this.lastVisit = Date.now();
    this.charge = Math.min(100, this.charge + CHARGE_PER_VISIT);
    if (this.state === 'dormant' || this.state === 'spore') {
      this.setState('resurgent');
      sounds.resurge();
      ribosome('resurge');
    }
    this.syncCharge();
    this.checkThreshold();
    autoSave();
  }

  setState(s) {
    this.state = s;
    this.el.dataset.state = s;
    this.el.querySelector('.state-dot').className = `state-dot ${s}`;
    if (s === 'spore') { sounds.dissolve(); ribosome('dissolve'); this.dissolveIntoMatrix(); }
    if (s === 'resurgent') { sounds.resurge(); ribosome('resurge'); }
    autoSave();
  }

  syncCharge() {
    const circ = 2 * Math.PI * 54;
    const arc = this.el.querySelector('.carc');
    if (arc) {
      const dash = (this.charge/100) * circ;
      arc.setAttribute('stroke-dasharray', `${dash} ${circ}`);
      arc.setAttribute('stroke', this.charge > 65 ? '#a8d878' : this.color);
      arc.setAttribute('opacity', this.charge > 50 ? 0.6 : 0.4);
    }
  }

  checkThreshold() {
    if (this.charge >= CHARGE_THRESHOLD && !this.isThreshold) {
      this.isThreshold = true;
      this.el.classList.add('threshold');
      sounds.threshold();
      ribosome('threshold');
      flashField();
      this.seekConnection();
    }
    if (this.charge < CHARGE_THRESHOLD * 0.5 && this.isThreshold) {
      this.isThreshold = false;
      this.el.classList.remove('threshold');
    }
  }

  seekConnection() {
    let best = null, bestScore = Infinity;
    cells.forEach(c => {
      if (c === this || c.state === 'spore') return;
      const d = Math.hypot(c.x - this.x, c.y - this.y);
      const score = d / (c.charge + 5);
      if (score < bestScore) { bestScore = score; best = c; }
    });
    if (best) addTube(this, best, true);
  }

  dissolveIntoMatrix() {
    for (let i = 0; i < 16; i++) {
      compost.push({
        x: this.x + (Math.random()-0.5)*90,
        y: this.y + (Math.random()-0.5)*90,
        r: 18 + Math.random()*55,
        born: Date.now(),
        life: 12000 + Math.random()*18000,
      });
    }
    ribosome('compost');
  }

  updateDisplay() {
    const intent = this.el.querySelector('.cell-intention');
    const ts = this.el.querySelector('.cell-timespan');
    const fodderContainer = this.el.querySelector('.fodder-in-cell');
    
    if (intent) intent.textContent = this.intention || 'forming...';
    if (ts) ts.textContent = `${this.timespan} ${this.unit}`;
    
    // Show fodder inside cell (first 3 items)
    if (fodderContainer) {
      const visibleFodder = this.fodder.slice(0, 3);
      if (visibleFodder.length > 0) {
        fodderContainer.innerHTML = visibleFodder.map(f => 
          `<span class="fodder-item-inner">${f.length > 20 ? f.slice(0,18)+'...' : f}</span>`
        ).join('');
      } else {
        fodderContainer.innerHTML = '';
      }
    }
    
    this.el.style.width = this.el.style.height = this.size + 'px';
    this.position();
    this.syncCharge();
    
    // Update gradients
    const grad = this.el.querySelector(`#grad-${this.id}`);
    if (grad) {
      grad.querySelectorAll('stop').forEach(stop => {
        stop.setAttribute('stop-color', this.color);
      });
    }
    const path = this.el.querySelector('.membrane-path');
    if (path) path.setAttribute('stroke', this.color);
    
    autoSave();
  }

  handleConnect() {
    if (!connectFrom) {
      connectFrom = this;
      this.el.style.outline = '1px solid rgba(143,188,106,0.55)';
      this.el.style.outlineOffset = '9px';
    } else if (connectFrom !== this) {
      addTube(connectFrom, this, false);
      sounds.connect(); ribosome('connection');
      connectFrom.el.style.outline = '';
      connectFrom = null;
    } else {
      connectFrom.el.style.outline = '';
      connectFrom = null;
    }
  }

  decay(dt) {
    if (this.state !== 'active' && this.state !== 'resurgent') return;
    this.charge = Math.max(0, this.charge - CHARGE_DECAY_RATE * dt);
    this.syncCharge();
    const idleS = (Date.now() - this.lastVisit) / 1000;
    if (this.charge < 10 && this.state === 'active' && idleS > DORMANT_IDLE_S) {
      this.setState('dormant');
    }
    this.checkThreshold();
  }

  remove() {
    if (this.state !== 'spore') this.dissolveIntoMatrix();
    this.el.remove();
    cells = cells.filter(c => c !== this);
    tubes = tubes.filter(t => t.from !== this && t.to !== this);
    autoSave();
  }
}

// ── Microtubules (connective tissue) ───────────────────────────────────────
function addTube(from, to, spontaneous) {
  if (tubes.find(t => (t.from===from&&t.to===to)||(t.from===to&&t.to===from))) return;
  tubes.push({ from, to, progress: 0, spontaneous, pOffset: Math.random(), strength: 0.25, tension: 0 });
}

function drawTubes() {
  mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);
  const now = Date.now();
  
  tubes.forEach(t => {
    t.progress = Math.min(1, t.progress + 0.006);
    t.strength = Math.min(0.6, t.strength + 0.0008);
    
    const {from, to} = t;
    const dx = to.x - from.x, dy = to.y - from.y;
    const dist = Math.hypot(dx, dy);
    
    // Tension based on charge difference (mechanotransduction)
    const chargeDiff = Math.abs(from.charge - to.charge);
    t.tension = chargeDiff / 100;
    
    const endX = from.x + dx * t.progress;
    const endY = from.y + dy * t.progress;
    
    // Organic curve with tension influence
    const curvature = 0.06 + t.tension * 0.04;
    const mx = (from.x+endX)/2 + dy*curvature;
    const my = (from.y+endY)/2 - dx*curvature;

    // Draw fascial fiber with organic quality
    mCtx.beginPath();
    mCtx.moveTo(from.x, from.y);
    mCtx.quadraticCurveTo(mx, my, endX, endY);
    
    const alpha = t.spontaneous ? t.strength * 0.65 : t.strength;
    const lineWidth = t.spontaneous ? 0.6 + t.tension * 0.4 : 1.0 + t.tension * 0.5;
    
    mCtx.strokeStyle = `rgba(100,160,90,${alpha * 0.4})`;
    mCtx.lineWidth = lineWidth;
    mCtx.setLineDash(t.spontaneous ? [3,8] : []);
    mCtx.stroke();
    mCtx.setLineDash([]);

    // Communication particles (instantaneous signal transmission)
    if (t.progress >= 1) {
      const particleCount = 1 + Math.floor(t.tension * 2);
      for (let i = 0; i < particleCount; i++) {
        const offset = i / particleCount;
        const p = ((now/3200) + t.pOffset + offset) % 1;
        const bx = (1-p)*(1-p)*from.x + 2*(1-p)*p*mx + p*p*to.x;
        const by = (1-p)*(1-p)*from.y + 2*(1-p)*p*my + p*p*to.y;
        mCtx.beginPath();
        mCtx.arc(bx, by, 1.5 + t.tension, 0, Math.PI*2);
        mCtx.fillStyle = `rgba(168,216,120,${0.3 + Math.sin(p*Math.PI)*0.3 + t.tension*0.2})`;
        mCtx.fill();
      }
    }
  });
}

// ── Field (matrix ground substance) ────────────────────────────────────────
function drawField() {
  fCtx.clearRect(0, 0, fCanvas.width, fCanvas.height);

  // Organic grid - irregular spacing
  fCtx.strokeStyle = 'rgba(35,52,38,0.08)';
  fCtx.lineWidth = 0.3;
  const baseSpacing = 95;
  for (let x = 0; x < fCanvas.width; x += baseSpacing + Math.sin(x*0.01)*8) {
    fCtx.beginPath();
    fCtx.moveTo(x,0);
    fCtx.lineTo(x + Math.sin(x*0.02)*10, fCanvas.height);
    fCtx.stroke();
  }
  for (let y = 0; y < fCanvas.height; y += baseSpacing + Math.cos(y*0.01)*8) {
    fCtx.beginPath();
    fCtx.moveTo(0,y);
    fCtx.lineTo(fCanvas.width, y + Math.cos(y*0.02)*10);
    fCtx.stroke();
  }

  // Compost / dissolved nutrients
  const now = Date.now();
  compost.forEach((p, i) => {
    const age = (now - p.born) / p.life;
    if (age > 1) { compost.splice(i, 1); return; }
    const alpha = Math.sin(age * Math.PI) * 0.06;
    const r = p.r * (1 + age * 2.2);
    const g = fCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
    g.addColorStop(0, `rgba(85,150,85,${alpha})`);
    g.addColorStop(0.7, `rgba(80,140,80,${alpha*0.3})`);
    g.addColorStop(1, 'transparent');
    fCtx.beginPath(); fCtx.arc(p.x, p.y, r, 0, Math.PI*2);
    fCtx.fillStyle = g; fCtx.fill();
  });
}

// ── Helpers ────────────────────────────────────────────────────────────────
function flashField() {
  const el = document.getElementById('threshold-flash');
  el.classList.add('flash');
  setTimeout(() => el.classList.remove('flash'), 70);
}

function ribosome(key) {
  const el = document.getElementById('ribosome');
  el.textContent = RIBOSOME[key] || RIBOSOME.default;
  el.classList.add('visible');
  if (ribTimer) clearTimeout(ribTimer);
  ribTimer = setTimeout(() => el.classList.remove('visible'), 6500);
}

// ── Persistence ────────────────────────────────────────────────────────────
function save() {
  const data = {
    cells: cells.map(c => ({
      id: c.id, x: c.x, y: c.y,
      intention: c.intention,
      timespan: c.timespan, unit: c.unit,
      color: c.color, size: c.size,
      fodder: c.fodder,
      state: c.state, charge: c.charge,
      lastVisit: c.lastVisit, born: c.born,
      isThreshold: c.isThreshold,
    })),
    tubes: tubes.map(t => ({
      fromId: t.from.id, toId: t.to.id,
      spontaneous: t.spontaneous,
    })),
    nextId, savedAt: Date.now(),
  };
  localStorage.setItem('cellular-calendar', JSON.stringify(data));
}

function load() {
  const stored = localStorage.getItem('cellular-calendar');
  if (!stored) return false;
  
  try {
    const data = JSON.parse(stored);
    nextId = data.nextId || 1;
    
    data.cells.forEach(cd => {
      const c = new Cell(cd.x, cd.y);
      c.id = cd.id;
      c.intention = cd.intention;
      c.timespan = cd.timespan;
      c.unit = cd.unit;
      c.color = cd.color;
      c.size = cd.size;
      c.fodder = cd.fodder || [];
      c.state = cd.state;
      c.charge = cd.charge;
      c.lastVisit = cd.lastVisit;
      c.born = cd.born;
      c.isThreshold = cd.isThreshold || false;
      c.setState(c.state);
      c.updateDisplay();
      cells.push(c);
    });
    
    data.tubes.forEach(td => {
      const from = cells.find(c => c.id === td.fromId);
      const to = cells.find(c => c.id === td.toId);
      if (from && to) {
        tubes.push({
          from, to, spontaneous: td.spontaneous,
          progress: 1, pOffset: Math.random(),
          strength: 0.5, tension: 0,
        });
      }
    });
    
    return true;
  } catch(e) {
    console.error('Load failed:', e);
    return false;
  }
}

let saveTimeout = null;
function autoSave() {
  if (saveTimeout) clearTimeout(saveTimeout);
  saveTimeout = setTimeout(save, 500);
}

// ── Select / Panel ─────────────────────────────────────────────────────────
function selectCell(cell) {
  if (selected) selected.el.classList.remove('selected');
  selected = cell;
  if (!cell) { renderPanel(null); return; }
  cell.el.classList.add('selected');
  document.getElementById('panel').classList.add('open');
  renderPanel(cell);
  autoSave();
}

function renderPanel(cell) {
  const title = document.getElementById('panel-title');
  const content = document.getElementById('panel-content');

  if (!cell) {
    title.textContent = 'cell';
    content.innerHTML = `<div id="panel-empty">select a cell<br>to tend it</div>`;
    return;
  }

  title.textContent = cell.intention || 'forming...';
  const cp = Math.round(cell.charge);
  const fHTML = cell.fodder.length
    ? cell.fodder.map((f,i) => `<div class="fodder-item" data-i="${i}">↳ ${f}</div>`).join('')
    : `<div style="color:var(--text-dim);font-size:11px;font-style:italic;padding:4px 0">empty — add nourishment</div>`;

  content.innerHTML = `
    <span class="field-label">intention</span>
    <input type="text" id="fi" value="${cell.intention}" placeholder="what does this cell hold?">

    <span class="field-label">timespan</span>
    <div class="timespan-row">
      <input type="number" id="ft" min="1" value="${cell.timespan}">
      <select id="fu">
        ${['hours','days','weeks','months','years'].map(u=>`<option ${cell.unit===u?'selected':''} value="${u}">${u}</option>`).join('')}
      </select>
    </div>

    <span class="field-label">state</span>
    <div class="state-selector">
      ${['active','dormant','spore','resurgent'].map(s=>
        `<button class="state-btn ${cell.state===s?'sel':''}" data-s="${s}">${s}</button>`
      ).join('')}
    </div>

    <span class="field-label">membrane</span>
    <input type="color" id="fc" value="${cell.color}">

    <span class="field-label">size</span>
    <input type="range" id="fs" min="80" max="240" value="${cell.size}">

    <span class="field-label">charge &nbsp;<span style="color:var(--charge);font-size:10px">${cp}%</span></span>
    <div class="charge-bar-outer"><div class="charge-bar-inner" style="width:${cp}%"></div></div>

    <hr class="div">
    <span class="field-label">fodder (visible inside cell: ${Math.min(cell.fodder.length, 3)} of ${cell.fodder.length})</span>
    <div id="flist">${fHTML}</div>
    <div class="fodder-add">
      <input type="text" id="ff" placeholder="add nourishment...">
      <button class="btn" id="badd">+</button>
    </div>

    <hr class="div">
    <div style="display:flex;gap:6px;flex-wrap:wrap">
      <button class="btn" id="bnourish">nourish</button>
      <button class="btn danger" id="bdissolve">dissolve</button>
    </div>
  `;

  const bind = (id, ev, fn) => document.getElementById(id)?.addEventListener(ev, fn);

  bind('fi','input', e => { cell.intention = e.target.value; title.textContent = cell.intention||'forming...'; cell.updateDisplay(); });
  bind('ft','input', e => { cell.timespan = Math.max(1,parseInt(e.target.value)||1); cell.updateDisplay(); });
  bind('fu','change', e => { cell.unit = e.target.value; cell.updateDisplay(); });
  bind('fc','input', e => { cell.color = e.target.value; cell.updateDisplay(); });
  bind('fs','input', e => { cell.size = parseInt(e.target.value); cell.updateDisplay(); });

  document.querySelectorAll('.state-btn').forEach(btn => btn.addEventListener('click', () => {
    cell.setState(btn.dataset.s);
    document.querySelectorAll('.state-btn').forEach(b=>b.classList.remove('sel'));
    btn.classList.add('sel');
    renderPanel(cell);
  }));

  document.querySelectorAll('.fodder-item').forEach(item => item.addEventListener('click', () => {
    cell.fodder.splice(parseInt(item.dataset.i),1);
    cell.updateDisplay();
    renderPanel(cell);
  }));

  bind('badd','click', () => {
    const v = document.getElementById('ff').value.trim();
    if (v) { cell.fodder.push(v); cell.visit(); cell.updateDisplay(); renderPanel(cell); }
  });
  bind('ff','keydown', e => { if(e.key==='Enter') document.getElementById('badd').click(); });

  bind('bnourish','click', () => { cell.visit(); renderPanel(cell); ribosome('charge'); });

  bind('bdissolve','click', () => {
    cell.setState('spore');
    renderPanel(cell);
    setTimeout(() => { if(cell.state==='spore') { cell.remove(); selectCell(null); document.getElementById('panel').classList.remove('open'); }}, 25000);
  });
}

// ── Controls ───────────────────────────────────────────────────────────────
document.getElementById('btn-new').addEventListener('click', () => {
  const c = new Cell(
    200 + Math.random() * (window.innerWidth - 500),
    80 + Math.random() * (window.innerHeight - 160)
  );
  cells.push(c);
  sounds.newCell();
  selectCell(c);
  autoSave();
});

document.getElementById('btn-connect').addEventListener('click', e => {
  connectMode = !connectMode;
  e.target.classList.toggle('active-mode');
  e.target.textContent = connectMode ? 'connecting...' : 'connect';
  if (!connectMode && connectFrom) { connectFrom.el.style.outline=''; connectFrom=null; }
});

document.getElementById('btn-sound').addEventListener('click', e => {
  soundOn = !soundOn;
  e.target.textContent = soundOn ? '♪ on' : '♪ off';
});

document.getElementById('close-panel').addEventListener('click', () => {
  document.getElementById('panel').classList.remove('open');
  if (selected) { selected.el.classList.remove('selected'); selected = null; }
});

document.body.addEventListener('click', e => {
  if (e.target === document.body || e.target === fCanvas || e.target === mCanvas) {
    if (selected) { selected.el.classList.remove('selected'); selected=null; }
    document.getElementById('panel').classList.remove('open');
  }
});

// ── Drag ───────────────────────────────────────────────────────────────────
document.addEventListener('mousemove', e => {
  if (dragging) dragging.move(e.clientX - dragOX, e.clientY - dragOY);
});
document.addEventListener('mouseup', () => { 
  if (dragging) autoSave();
  dragging = null;
});

// ── Animation ──────────────────────────────────────────────────────────────
let lastT = Date.now();
function animate() {
  const now = Date.now();
  const dt = (now - lastT) / 1000;
  lastT = now;
  cells.forEach(c => c.decay(dt));
  drawField();
  drawTubes();
  requestAnimationFrame(animate);
}
animate();

// ── Status cycling ─────────────────────────────────────────────────────────
const statusMsgs = [
  'inhabit like you live here',
  'cells nourished by attention',
  'charge builds toward threshold',
  'the matrix holds what dissolves',
  'thresholds make patterns legible',
  'nothing lost — everything transforms',
  'connective tissue carries light and tension',
  'ask through resonance, not declaration',
];
let sIdx = 0;
const statusEl = document.getElementById('status');
statusEl.style.transition = 'opacity 0.5s';
setInterval(() => {
  sIdx = (sIdx+1) % statusMsgs.length;
  statusEl.style.opacity = 0;
  setTimeout(() => { statusEl.textContent = statusMsgs[sIdx]; statusEl.style.opacity = 1; }, 500);
}, 13000);

// ── Initialize ─────────────────────────────────────────────────────────────
const loaded = load();

if (!loaded) {
  const seed = new Cell(window.innerWidth * 0.4, window.innerHeight * 0.48);
  seed.intention = 'now';
  seed.timespan = 1; seed.unit = 'days';
  seed.charge = 28;
  seed.updateDisplay();
  cells.push(seed);
  save();
}
</script>
</body>
</html>
